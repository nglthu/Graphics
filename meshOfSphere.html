<!DOCTYPE html>
<html>

<head>
    <script type="text/javascript" src="https://getfirebug.com/firebug-lite-debug.js"></script>
    <meta name="description" content="Computer Graphics - Exercise #1" />
    <meta charset="utf-8" />
    <title>Sample Three.js</title>
    <style>
        #container {
            background: #000000;
            width: 100%;
            height: 100%;
        }
    </style>
    <meta charset=utf-8 />
    <title>Three.js - #1</title>

    <style id="jsbin-css">
    </style>
</head>

<body>
    <div id="container">
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/85/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.5/dat.gui.min.js"></script>
<script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js"></script>
<script src="http://uopeopleweb.com/js/math.js"></script>
<script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/Detector.js"></script>
<script type="text/javascript">
    // set the scene size
    var WIDTH = 500,
        HEIGHT = 500;

    // set some camera attributes
    var VIEW_ANGLE = 45,
        ASPECT = WIDTH / HEIGHT,
        NEAR = 1,
        FAR = 1000;

    // get the DOM element to attach to
    var $container = $('#container');

    // create a WebGL renderer, camera, and a scene
    if (Detector.webgl)
        var renderer = new THREE.WebGLRenderer();
    else
        var renderer = new THREE.CanvasRenderer();

    var scene = new THREE.Scene();
    var clock = new THREE.Clock();
    var camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
    // the camera starts at 0,0,0 so pull it back
    camera.position.z = 200;
    // add the camera to the scene
    scene.add(camera)

    // set up the camera controls.  Please keep in mind that what this does is move the entire scene around.
    // because the entire scene is moving the position of the camera and lights in relation to objects within 
    // the scene doesn't change so the lighting on the surface of the object(s) will not change either
    var cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
    cameraControls.addEventListener('mousemove', renderer);
    cameraControls.autoRotate = true;

    // start the renderer
    renderer.setSize(WIDTH, HEIGHT);

    // attach the render-supplied DOM element
    $container.append(renderer.domElement);


    // create a point light
    var areaLight = new THREE.RectAreaLight(0x004C00, 1);

    // add to the scene
    scene.add(areaLight);

    //create the sphere's material
        var sphereMaterial = new THREE.MeshNormalMaterial({
            color: 0x004C00
        });

//    var sphereMaterial = new THREE.MeshBasicMaterial({ // color: 0xFF0000, // transparent: true, // opacity: 0.5 // });
    // set up the sphere vars
    var radius = 50,
        segments = 32,
        rings = 32;

    // create a new mesh with sphere geometry -
    // we will cover the sphereMaterial next!
    var sphere = new THREE.Mesh(
        new THREE.SphereGeometry(radius, segments, rings),
        sphereMaterial);


    ////particleGeometry=sphere
    //particleMaterial=sphereMaterials
    screen.add(sphere);


    //     Standard functions for rendering the scene.  Notice how we have the animate function 
    //     which submits a call to requestAnimationFrame to call animate.   This creates a loop
    //     that will render the scene again whenever something within the scene changes.
    function animate() {
        requestAnimationFrame(animate);
        render();

    }

    function render() {
        cameraControls.update();
        renderer.render(scene, camera);





    }
    animate();
</script>

<!--
    var that;
var BouncingBalls = function(){
    this.scene = new THREE.Scene();
    that = this;
};

BouncingBalls.prototype.init = function(){
    this.createCamera();
    this.createRenderer();

    this.createBoxes();

    this.createFloor();
    this.createLights();

    this.animateBalls();

    this.render();
    this.datGUI();
};

BouncingBalls.prototype.createCamera = function(){
    this.camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -1000, 1000 );
    this.camera.position.x = 100;
    this.camera.position.y = 100;
    this.camera.position.z = 100;

    this.camera.lookAt(new THREE.Vector3(0,0,0));
    this.camera.zoom = 0.5;
    this.camera.updateProjectionMatrix();

    //Adjust the scene to center the balls
    this.scene.position.z = 170;
    this.scene.position.y = -70;
};

/*Display or not 2D view*/
BouncingBalls.prototype.swap2DView = function(value){
    if(value == true){
        this.camera.position.set(100,0,0);
        this.scene.position.y = -120;
    }
    else{
        this.camera.position.set(100,100,100);
        this.scene.position.y = -70;
    }
    this.controls.update(); //update camera view
};

BouncingBalls.prototype.createRenderer = function(){
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setSize( window.innerWidth, window.innerHeight );
    this.renderer.setClearColor( 0xededed);
    this.renderer.shadowMapEnabled = true;
    this.renderer.shadowMapType = THREE.PCFSoftShadowMap;
    this.renderer.shadowMapSoft = true;
    document.body.appendChild( this.renderer.domElement );
    window.addEventListener('resize', this.onWindowResize, false);

    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement); //rotate camera with the mouse
    this.controls.enablePan = false; //disable pan because it causes bugs
};

BouncingBalls.prototype.createBoxes = function(){
    this.spheres = [];
    var materials = [];
    var spherePosY = 250;
    var spherePosZ = 0;

    var geometry = new THREE.SphereGeometry( 40, 32, 32 );
    materials[1] = new THREE.MeshBasicMaterial( {color: 0x669BF2, shading: THREE.SmoothShading} );
    materials[2] = new THREE.MeshBasicMaterial( {color: 0xEA4335, shading: THREE.SmoothShading} );
    materials[3] = new THREE.MeshBasicMaterial( {color: 0xFBBC05, shading: THREE.SmoothShading} );
    materials[4] = new THREE.MeshBasicMaterial( {color: 0x34A853, shading: THREE.SmoothShading} );

    for(var i=1;i<=4;i++){
        this.spheres[i] = new THREE.Mesh(geometry, materials[i]);
        this.spheres[i].position.y = spherePosY;
        this.spheres[i].position.z = spherePosZ;
        this.spheres[i].castShadow = true;
        this.spheres[i].receiveShadow = true;
        this.scene.add(this.spheres[i]);
        spherePosY+= 50;
        spherePosZ+= -120;
    }
};

BouncingBalls.prototype.createFloor = function(){
    var geometry2 = new THREE.PlaneBufferGeometry( 1000, 1000);
    var material2 = new THREE.MeshBasicMaterial( { color: 0xededed } );
    var floor = new THREE.Mesh( geometry2, material2 );
    floor.material.side = THREE.DoubleSide;
    floor.rotation.x = 90*Math.PI/180;
    floor.doubleSided = true;
    floor.receiveShadow = true;
    this.scene.add(floor);
};

BouncingBalls.prototype.createLights = function(){
    var shadowLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
    shadowLight.position.set( -400, 1000, 0 );
    shadowLight.target.position.set(this.scene.position);
    shadowLight.castShadow = true;
    shadowLight.shadowDarkness = 0.1;
    //shadowLight.shadowCameraVisible = true;
    this.scene.add(shadowLight);
};


BouncingBalls.prototype.animateBalls = function(){
    this.tl = new TimelineMax({repeat: -1 , repeatDelay:0});
    this.tl.to(this.spheres[1].position, 0.6, {y: 40, ease: Power2.easeIn});
    this.tl.to(this.spheres[1].position, 0.95, {y: 250, ease: Circ.easeOut});

    this.t2 = new TimelineMax({repeat: -1 , repeatDelay:0});
    this.t2.to(this.spheres[2].position, 0.75, {y: 40, ease: Power2.easeIn});
    this.t2.to(this.spheres[2].position, 0.8, {y: 300, ease: Circ.easeOut});

    this.t3 = new TimelineMax({repeat: -1 , repeatDelay:0});
    this.t3.to(this.spheres[3].position, 0.9, {y: 40, ease: Power2.easeIn});
    this.t3.to(this.spheres[3].position, 0.65, {y: 350, ease: Circ.easeOut});

    this.t4 = new TimelineMax({repeat: -1 , repeatDelay:0});
    this.t4.to(this.spheres[4].position, 1.05, {y: 40, ease: Power2.easeIn});
    this.t4.to(this.spheres[4].position, 0.50, {y: 400, ease: Circ.easeOut});
};


BouncingBalls.prototype.render = function(){
    requestAnimationFrame(this.render.bind(this));
    this.renderer.render(this.scene, that.camera);
};

BouncingBalls.prototype.onWindowResize = function(){
    that.camera.left = window.innerWidth / -2;
    that.camera.right = window.innerWidth / 2;
    that.camera.top = window.innerHeight / 2;
    that.camera.bottom = window.innerHeight / -2;
    that.camera.updateProjectionMatrix();
    that.renderer.setSize(window.innerWidth, window.innerHeight);
};

/*User interface - display or not 2D view*/
BouncingBalls.prototype.datGUI = function(){
    var Configuration = function(){
      this.view2D = false;
    };
    var config = new Configuration();

    var gui = new dat.GUI();
    gui.add(config, 'view2D').onFinishChange(function(){
        that.swap2DView(config.view2D);
    });


};

var bouncingBalls = new BouncingBalls();
bouncingBalls.init();
-->

</html>